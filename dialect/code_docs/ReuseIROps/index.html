<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Ops - ReuseIR</title><meta name=description content="Reuse Analysis in MLIR and Rust"><meta name=generator content="Hugo 0.119.0"><link href=https://SchrodingerZhu.github.io/ReuseIRindex.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://SchrodingerZhu.github.io/ReuseIR/dialect/code_docs/ReuseIROps/><link rel=stylesheet href=https://SchrodingerZhu.github.io/ReuseIR/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://SchrodingerZhu.github.io/ReuseIR/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://SchrodingerZhu.github.io/ReuseIR/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://SchrodingerZhu.github.io/ReuseIR/reuseir-logo-40x40.png width=40px align=absmiddle>
ReuseIR</div></h1><p class=description>Reuse Analysis in MLIR and Rust</p></header><div class=global-menu><nav><ul><li class=parent><a href=https://github.com/SchrodingerZhu/ReuseIR/issues>Issues<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://github.com/SchrodingerZhu/ReuseIR/issues/new/choose>Report issue</a></li></ul></li><li class=parent><a href=https://github.com/SchrodingerZhu/ReuseIR>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://github.com/SchrodingerZhu/ReuseIR/tree/main/reuse-runtime>Runtime</a></li><li class=child><a href=https://github.com/SchrodingerZhu/ReuseIR/tree/main/reuse-frontend>Frontend</a></li><li class=child><a href=https://github.com/SchrodingerZhu/ReuseIR/tree/main/reuse-mlir>Dialect</a></li></ul></li><li><a href=https://github.com/SchrodingerZhu/ReuseIR/releases>Releases</a></li></ul></nav></div><div class=content-container><main><h1>Ops</h1><h3 id=reuse_irclone-reuse_ircloneop><code>reuse_ir.clone</code> (reuse_ir::CloneOp)&nbsp;<a class=headline-hash href=#reuse_irclone-reuse_ircloneop>¶</a></h3><p><em>Make sure the object behind the reference can be value-copied</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.clone` `(` $object `:` type($object) `)` (`tag` `(` $tag^ `)`)? attr-dict `:` type($result)
</code></pre><p><code>reuse_ir.clone</code> applies shadow copy to the object behind the reference. That is,
it will increase the reference count of sub fields if necessary.</p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tag</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr></table><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>object</code></td><td>ReuseIR Reference Type</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=reuse_irclosureapply-reuse_irclosureapplyop><code>reuse_ir.closure.apply</code> (reuse_ir::ClosureApplyOp)&nbsp;<a class=headline-hash href=#reuse_irclosureapply-reuse_irclosureapplyop>¶</a></h3><p><em>Apply one more argument to the closure</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.closure.apply` $closure `(` $args `)` attr-dict `:` functional-type(operands, results)
</code></pre><p><code>closure.apply</code> adds one more argument to the closure&rsquo;s argpack.
This operation &ldquo;consumes&rdquo; both the closure and the argument. The RC shall be increased
if relevant objects are still to be used after the operation.</p><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>closure</code></td><td>RcType of certain types</td></tr><tr><td style=text-align:center><code>args</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>RcType of certain types</td></tr></tbody></table><h3 id=reuse_irclosureassemble-reuse_irclosureassembleop><code>reuse_ir.closure.assemble</code> (reuse_ir::ClosureAssembleOp)&nbsp;<a class=headline-hash href=#reuse_irclosureassemble-reuse_irclosureassembleop>¶</a></h3><p><em>Create a new closure with given resources</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.closure.assemble` `vtable` `(` $vtable `)`
              (`argpack` `(` $argpack^ `:` type($argpack) `)` )?
              `:` attr-dict type($closure)
</code></pre><p><code>reuse_ir.closure.assemble</code> creates a new closure object.
The closure can either be a value or wrapped in a rc pointer.
The closure shall not capture mutable references (for now).</p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>vtable</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>argpack</code></td><td>ReuseIR Memory Token</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>closure</code></td><td>ReuseIR Closure Type</td></tr></tbody></table><h3 id=reuse_irclosureeval-reuse_irclosureevalop><code>reuse_ir.closure.eval</code> (reuse_ir::ClosureEvalOp)&nbsp;<a class=headline-hash href=#reuse_irclosureeval-reuse_irclosureevalop>¶</a></h3><p><em>Evaluate a fully applied closure</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.closure.eval` `(` $closure `)` attr-dict `:` functional-type(operands, results)
</code></pre><p><code>closure.eval</code> evaluates a fully applied closure.
The operation consumes the closure.</p><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>closure</code></td><td>RcType of certain types</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=reuse_irclosurenew-reuse_irclosurenewop><code>reuse_ir.closure.new</code> (reuse_ir::ClosureNewOp)&nbsp;<a class=headline-hash href=#reuse_irclosurenew-reuse_irclosurenewop>¶</a></h3><p><em>Create a new closure</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.closure.new` ($body^)? `:` type($closure) attr-dict
</code></pre><p><code>reuse_ir.closure.new</code> creates a new closure object (without wrapping it into RC).
The closure shall not capture mutable references (for now).</p><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>closure</code></td><td>ReuseIR Closure Type</td></tr></tbody></table><h3 id=reuse_irclosurevtable-reuse_irclosurevtableop><code>reuse_ir.closure.vtable</code> (reuse_ir::ClosureVTableOp)&nbsp;<a class=headline-hash href=#reuse_irclosurevtable-reuse_irclosurevtableop>¶</a></h3><p><em>Define a closure vtable</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.closure.vtable` attr-dict $name `{`
              `closure_type` `:` $closureType `,`
              `func` `:` $func `,`
              `clone` `:` $clone `,`
              `drop` `:` $drop
              `}`
</code></pre><p><code>closure.vtable</code> defines a vtable for the closure.
The vtable is a list of function pointers.</p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>closureType</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr><tr><td><code>func</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>clone</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>drop</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h3 id=reuse_irclosureyield-reuse_irclosureyieldop><code>reuse_ir.closure.yield</code> (reuse_ir::ClosureYieldOp)&nbsp;<a class=headline-hash href=#reuse_irclosureyield-reuse_irclosureyieldop>¶</a></h3><p><em>Yield closure return value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.closure.yield` ($value^ `:` type($value))? attr-dict
</code></pre><p><code>closure.yield</code> yields the return value of the closure.
This serves as the terminator of the closure body.</p><p>Traits: <code>HasParent&lt;::mlir::reuse_ir::ClosureNewOp></code>, <code>ReturnLike</code>, <code>Terminator</code></p><p>Interfaces: <code>RegionBranchTerminatorOpInterface</code></p><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>any type</td></tr></tbody></table><h3 id=reuse_ircompositeassemble-reuse_ircompositeassembleop><code>reuse_ir.composite.assemble</code> (reuse_ir::CompositeAssembleOp)&nbsp;<a class=headline-hash href=#reuse_ircompositeassemble-reuse_ircompositeassembleop>¶</a></h3><p><em>Create a new composite object</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.composite.assemble` `(` $fields `)` attr-dict `:` functional-type(operands, results)
</code></pre><p><code>reuse_ir.composite.assemble</code> creates a new composite object.</p><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>fields</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>composite</code></td><td>ReuseIR composite type</td></tr></tbody></table><h3 id=reuse_irdestroy-reuse_irdestroyop><code>reuse_ir.destroy</code> (reuse_ir::DestroyOp)&nbsp;<a class=headline-hash href=#reuse_irdestroy-reuse_irdestroyop>¶</a></h3><p><em>Destroy a value type or a referential type</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.destroy` `(` $object `:` type($object) `)` (`tag` `(` $tag^ `)`)? attr-dict
</code></pre><ul><li>For composite/union type (either a reference or the value),
this operation project out the fields that require additional
maintenance and apply the required operations.<ul><li>For RC type, it applies the <code>reuse_ir.rc.release</code> operation.</li><li>For nested composite/union types, it recursively applies the
<code>reuse_ir.destroy</code> operation.</li></ul></li><li>Specialized types such as Opaque/Vector/Closure are specially handled.</li></ul><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tag</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr></table><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>object</code></td><td>ReuseIR Reference Type</td></tr></tbody></table><h3 id=reuse_irrcfvtable-reuse_irfreezablevtableop><code>reuse_ir.rc.fvtable</code> (reuse_ir::FreezableVTableOp)&nbsp;<a class=headline-hash href=#reuse_irrcfvtable-reuse_irfreezablevtableop>¶</a></h3><p><em>Define a vtable for freezable rc objects</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.rc.fvtable` attr-dict $name `{`
              (`drop` `:` $drop^ `,`)?
              (`scanner` `:` $scanner^ `,`)?
              `size` `:` $size `,`
              `alignment` `:` $alignment `,`
              `data_offset` `:` $dataOffset
              `}`
</code></pre><p><code>rc.fvtable</code> defines a vtable for the freezable rc objects.</p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>drop</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>scanner</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>size</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr><tr><td><code>alignment</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr><tr><td><code>dataOffset</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr></table><h3 id=reuse_irload-reuse_irloadop><code>reuse_ir.load</code> (reuse_ir::LoadOp)&nbsp;<a class=headline-hash href=#reuse_irload-reuse_irloadop>¶</a></h3><p><em>Load a value from a reference</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.load` $object attr-dict `:` type($object) `-&gt;` type($result)
</code></pre><p><code>reuse_ir.load</code> loads the value from the reference.
One special thing is the mref type, which will be
loaded as a <code>reuse_ir.rc</code> type, whose freezing state
inherits from the parent reference.</p><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>object</code></td><td>ReuseIR Reference Type</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=reuse_irmrefassign-reuse_irmrefassignop><code>reuse_ir.mref.assign</code> (reuse_ir::MRefAssignOp)&nbsp;<a class=headline-hash href=#reuse_irmrefassign-reuse_irmrefassignop>¶</a></h3><p><em>Assign a value to a mutable reference</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.mref.assign` $value `to` $refOfMRef attr-dict `:` type($value) `,` type($refOfMRef)
</code></pre><p><code>reuse_ir.mref.assign</code> assigns a value to a mutable reference.</p><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>refOfMRef</code></td><td>RcType of certain types</td></tr><tr><td style=text-align:center><code>value</code></td><td>ReuseIR Nullable Type</td></tr></tbody></table><h3 id=reuse_irnullablecheck-reuse_irnullablecheckop><code>reuse_ir.nullable.check</code> (reuse_ir::NullableCheckOp)&nbsp;<a class=headline-hash href=#reuse_irnullablecheck-reuse_irnullablecheckop>¶</a></h3><p><em>Check the nullibility of a pointer</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.nullable.check` `(` $nullable `:` type($nullable) `)` attr-dict `-&gt;` type($result)
</code></pre><p><code>reuse_ir.nullable.check</code> returns 1 if target pointer is null or 0 otherwise.</p><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>nullable</code></td><td>ReuseIR Nullable Type</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=reuse_irnullablecoerce-reuse_irnullablecoerceop><code>reuse_ir.nullable.coerce</code> (reuse_ir::NullableCoerceOp)&nbsp;<a class=headline-hash href=#reuse_irnullablecoerce-reuse_irnullablecoerceop>¶</a></h3><p><em>Force unwrap the nullable as a nonnull pointer</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.nullable.coerce` `(` $nullable `:` type($nullable) `)` attr-dict `:` type($result)
</code></pre><p><code>reuse_ir.nullable.coerce</code> forcibly unwrap the nullable as a nonnull pointer.</p><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>nullable</code></td><td>ReuseIR Nullable Type</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>ReuseIR Rc Pointer Type or ReuseIR Memory Token</td></tr></tbody></table><h3 id=reuse_irnullablenonnull-reuse_irnullablenonnullop><code>reuse_ir.nullable.nonnull</code> (reuse_ir::NullableNonNullOp)&nbsp;<a class=headline-hash href=#reuse_irnullablenonnull-reuse_irnullablenonnullop>¶</a></h3><p><em>Create a nullable pointer from a nonnull value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.nullable.nonnull` `(` $pointer `:` type($pointer) `)` attr-dict `:` type($result)
</code></pre><p><code>reuse_ir.nullable.nonnull</code> creates a nullable pointer from a nonnull value.</p><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pointer</code></td><td>ReuseIR Rc Pointer Type or ReuseIR Memory Token</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>ReuseIR Nullable Type</td></tr></tbody></table><h3 id=reuse_irnullablenull-reuse_irnullablenullop><code>reuse_ir.nullable.null</code> (reuse_ir::NullableNullOp)&nbsp;<a class=headline-hash href=#reuse_irnullablenull-reuse_irnullablenullop>¶</a></h3><p><em>Create a null pointer</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.nullable.null` attr-dict `:` type($result)
</code></pre><p><code>reuse_ir.nullable.null</code> creates a null pointer.</p><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>ReuseIR Nullable Type</td></tr></tbody></table><h3 id=reuse_irpanic-reuse_irpanicop><code>reuse_ir.panic</code> (reuse_ir::PanicOp)&nbsp;<a class=headline-hash href=#reuse_irpanic-reuse_irpanicop>¶</a></h3><p><em>Panic the program</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.panic` `(` $message `)` attr-dict (`:` type($result)^)?
</code></pre><p><code>reuse_ir.panic</code> panics the program.</p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>message</code></td><td>::mlir::StringAttr</td><td><details><summary>An Attribute containing a string</summary><pre><code>Syntax:
<pre tabindex=0><code>string-attribute ::= string-literal (`:` type)?
</code></pre><p>A string attribute is an attribute that represents a string literal value.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=err>&amp;</span>quot<span class=err>;</span>An important string<span class=err>&amp;</span>quot<span class=err>;</span>
</span></span><span class=line><span class=cl><span class=err>&amp;</span>quot<span class=err>;</span>string with a type<span class=err>&amp;</span>quot<span class=err>;</span> <span class=p>:</span> <span class=p>!</span>dialect<span class=p>.</span>string
</span></span></code></pre></div><p></code></pre></p></details></td></tr></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=reuse_irproj-reuse_irprojop><code>reuse_ir.proj</code> (reuse_ir::ProjOp)&nbsp;<a class=headline-hash href=#reuse_irproj-reuse_irprojop>¶</a></h3><p><em>Project a field out of a value type or a referential type</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.proj` $object `[` $index `]` attr-dict `:` type($object) `-&gt;` type($result)
</code></pre><p><code>reuse_ir.proj</code> gets a reference to the field of the object similar to the
GEP operation in LLVM IR without the first index.
The freezing attribute is inherited from the parent reference.</p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr></table><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>object</code></td><td>ReuseIR Reference Type</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>ReuseIR Reference Type</td></tr></tbody></table><h3 id=reuse_irrcacquire-reuse_irrcacquireop><code>reuse_ir.rc.acquire</code> (reuse_ir::RcAcquireOp)&nbsp;<a class=headline-hash href=#reuse_irrcacquire-reuse_irrcacquireop>¶</a></h3><p><em>Increase reference count</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.rc.acquire` `(` $rcPtr `:` type($rcPtr) `)` attr-dict
</code></pre><p><code>reuse_ir.rc.acquire</code> increases the reference count of the object.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>reuse_ir<span class=p>.</span>rc<span class=p>.</span>acquire <span class=p>(</span><span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>reuse_ir<span class=p>.</span>rc<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;)</span>
</span></span></code></pre></div><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>rcPtr</code></td><td>ReuseIR Rc Pointer Type</td></tr></tbody></table><h3 id=reuse_irrcas_ptr-reuse_irrcasptrop><code>reuse_ir.rc.as_ptr</code> (reuse_ir::RcAsPtrOp)&nbsp;<a class=headline-hash href=#reuse_irrcas_ptr-reuse_irrcasptrop>¶</a></h3><p><em>Cast rc pointer to LLVM opaque pointer</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.rc.as_ptr` `(` $rc `:` type($rc) `)` attr-dict `:` type($result)
</code></pre><p><code>rc.as_ptr</code> casts the rc pointer to LLVM opaque pointer.</p><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>rc</code></td><td>ReuseIR Rc Pointer Type</td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>ReuseIR opaque pointer type</td></tr></tbody></table><h3 id=reuse_irrcborrow-reuse_irrcborrowop><code>reuse_ir.rc.borrow</code> (reuse_ir::RcBorrowOp)&nbsp;<a class=headline-hash href=#reuse_irrcborrow-reuse_irrcborrowop>¶</a></h3><p><em>Borrow the managed object and get the reference</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.rc.borrow` $object attr-dict `:` type($object) `-&gt;` type($result)
</code></pre><p><code>reuse_ir.rc.borrow</code> is used to get the reference to the managed object.</p><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>object</code></td><td>ReuseIR Rc Pointer Type</td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>ReuseIR Reference Type</td></tr></tbody></table><h3 id=reuse_irrccreate-reuse_irrccreateop><code>reuse_ir.rc.create</code> (reuse_ir::RcCreateOp)&nbsp;<a class=headline-hash href=#reuse_irrccreate-reuse_irrccreateop>¶</a></h3><p><em>Create a new Rc object</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.rc.create` `value` `(` $value `)`
              `token` `(` $token `)`
              (`region` `(` $region^ `)`)?
              attr-dict `:` functional-type(operands, results)
</code></pre><p><code>reuse_ir.rc.create</code> creates a new Rc object.</p><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>any type</td></tr><tr><td style=text-align:center><code>token</code></td><td>ReuseIR Memory Token</td></tr><tr><td style=text-align:center><code>region</code></td><td>ReuseIR Region Context</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>rc</code></td><td>ReuseIR Rc Pointer Type</td></tr></tbody></table><h3 id=reuse_irrcdecrease-reuse_irrcdecreaseop><code>reuse_ir.rc.decrease</code> (reuse_ir::RcDecreaseOp)&nbsp;<a class=headline-hash href=#reuse_irrcdecrease-reuse_irrcdecreaseop>¶</a></h3><p><em>Decrease reference count</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.rc.decrease` `(` $rcPtr `:` type($rcPtr) `)` attr-dict `:`  type($dropFlag)
</code></pre><p>This decrement operation is for progressively lowering rc.release operation. It decreases
the reference count and return a flag indicating whether the object should be dropped.</p><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>rcPtr</code></td><td>ReuseIR Rc Pointer Type</td></tr></tbody></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dropFlag</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=reuse_irrcfreeze-reuse_irrcfreezeop><code>reuse_ir.rc.freeze</code> (reuse_ir::RcFreezeOp)&nbsp;<a class=headline-hash href=#reuse_irrcfreeze-reuse_irrcfreezeop>¶</a></h3><p><em>Freeze the Rc object</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.rc.freeze` `(` $rcPtr `:` type($rcPtr) `)` attr-dict `:` type($result)
</code></pre><p><code>reuse_ir.rc.freeze</code> freezes the Rc object. Limited by the control flow interface of the MLIR, the RegionYieldOp must have consistent type
with its parent RegionRunOp. Hence, we cannot automatically freeze the Rc object. This operation serves a marker for such conversion. It is up to
the user to make sure that this operation is applied only for the use of yielding the Rc object. Object after being frozen shall not be modified.</p><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>rcPtr</code></td><td>ReuseIR Rc Pointer Type</td></tr></tbody></table><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>ReuseIR Rc Pointer Type</td></tr></tbody></table><h3 id=reuse_irrcis_unique-reuse_irrcisuniqueop><code>reuse_ir.rc.is_unique</code> (reuse_ir::RcIsUniqueOp)&nbsp;<a class=headline-hash href=#reuse_irrcis_unique-reuse_irrcisuniqueop>¶</a></h3><p><em>Check if the underlying object is unique</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.rc.is_unique` `(` $rc `:` type($rc) `)` attr-dict `:` type($result)
</code></pre><p><code>rc.is_unique</code> checks if the underlying object is unique.</p><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>rc</code></td><td>ReuseIR Rc Pointer Type</td></tr></tbody></table><h4 id=results-18>Results:&nbsp;<a class=headline-hash href=#results-18>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=reuse_irrcrelease-reuse_irrcreleaseop><code>reuse_ir.rc.release</code> (reuse_ir::RcReleaseOp)&nbsp;<a class=headline-hash href=#reuse_irrcrelease-reuse_irrcreleaseop>¶</a></h3><p><em>Release reference count and drop the object if necessary</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.rc.release` `(` $rcPtr `:` type($rcPtr) `)` (`tag` `(` $tag^ `)`)? attr-dict  (`:` type($token)^)?
</code></pre><p><code>reuse_ir.rc.release</code> decreases the reference count of the object.</p><ul><li>It target rc is a freezable one, it has no result. The operation translates to runtime function call.</li><li>If the target rc is not freezable, it returns a nullable token.</li></ul><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tag</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr></table><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>rcPtr</code></td><td>ReuseIR Rc Pointer Type</td></tr></tbody></table><h4 id=results-19>Results:&nbsp;<a class=headline-hash href=#results-19>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>token</code></td><td>RcType of certain types</td></tr></tbody></table><h3 id=reuse_irrctokenize-reuse_irrctokenizeop><code>reuse_ir.rc.tokenize</code> (reuse_ir::RcTokenizeOp)&nbsp;<a class=headline-hash href=#reuse_irrctokenize-reuse_irrctokenizeop>¶</a></h3><p><em>Convert the rc to a token that is suitable for its underlying RcBox</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.rc.tokenize` $object attr-dict `:` type($object) `-&gt;` type($token)
</code></pre><p><code>reuse_ir.rc.tokenize</code> converts the rc to a token that is suitable for its underlying RcBox.</p><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>object</code></td><td>ReuseIR Rc Pointer Type</td></tr></tbody></table><h4 id=results-20>Results:&nbsp;<a class=headline-hash href=#results-20>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>token</code></td><td>ReuseIR Memory Token</td></tr></tbody></table><h3 id=reuse_irrcuniquify-reuse_irrcuniquifyop><code>reuse_ir.rc.uniquify</code> (reuse_ir::RcUniquifyOp)&nbsp;<a class=headline-hash href=#reuse_irrcuniquify-reuse_irrcuniquifyop>¶</a></h3><p><em>Make sure the underlying object is unique</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.rc.uniquify` `(` $rc `:` type($rc) `)` attr-dict `:` type($result)
</code></pre><p><code>rc.uniquify</code> makes sure the underlying object is unique.</p><ul><li>If the count is 1, it returns the object itself.</li><li>Otherwise, it clones the object and returns the new object.
The original rc is dropped.</li></ul><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>rc</code></td><td>ReuseIR Rc Pointer Type</td></tr></tbody></table><h4 id=results-21>Results:&nbsp;<a class=headline-hash href=#results-21>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>ReuseIR Rc Pointer Type</td></tr></tbody></table><h3 id=reuse_irregioncleanup-reuse_irregioncleanupop><code>reuse_ir.region.cleanup</code> (reuse_ir::RegionCleanUpOp)&nbsp;<a class=headline-hash href=#reuse_irregioncleanup-reuse_irregioncleanupop>¶</a></h3><p><em>Clean up the region ctx</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.region.cleanup` `(` $regionCtx `:` type($regionCtx) `)` attr-dict
</code></pre><p><code>reuse_ir.region.cleanup</code> cleans up the region ctx. It serves as an intermediate placeholder for lowering <code>region.run</code> operation.</p><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>regionCtx</code></td><td>ReuseIR Region Context</td></tr></tbody></table><h3 id=reuse_irregioncreate-reuse_irregioncreateop><code>reuse_ir.region.create</code> (reuse_ir::RegionCreateOp)&nbsp;<a class=headline-hash href=#reuse_irregioncreate-reuse_irregioncreateop>¶</a></h3><p><em>Create a new region ctx</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.region.create` attr-dict `:` type($regionCtx)
</code></pre><p><code>reuse_ir.region.create</code> creates a new region ctx. It serves as an intermediate placeholder for lowering <code>region.run</code> operation.</p><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=results-22>Results:&nbsp;<a class=headline-hash href=#results-22>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>regionCtx</code></td><td>ReuseIR Region Context</td></tr></tbody></table><h3 id=reuse_irregionrun-reuse_irregionrunop><code>reuse_ir.region.run</code> (reuse_ir::RegionRunOp)&nbsp;<a class=headline-hash href=#reuse_irregionrun-reuse_irregionrunop>¶</a></h3><p><em>Create a new region</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.region.run` ($body^)? attr-dict (`:` type($result)^)?
</code></pre><p><code>reuse_ir.region.run</code> creates a new region.</p><p>Interfaces: <code>RegionBranchOpInterface</code></p><h4 id=results-23>Results:&nbsp;<a class=headline-hash href=#results-23>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=reuse_irregionyield-reuse_irregionyieldop><code>reuse_ir.region.yield</code> (reuse_ir::RegionYieldOp)&nbsp;<a class=headline-hash href=#reuse_irregionyield-reuse_irregionyieldop>¶</a></h3><p><em>Yield region return value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.region.yield` $value attr-dict `:` type($value)
</code></pre><p><code>region.yield</code> yields the return value of the region.
This serves as the terminator of the region body. When a region exists, all objects
are scanned from the tail pointer. The freeze operation serves as a marking process.
All other regional objects that are not marked are recycled.</p><p>Traits: <code>HasParent&lt;::mlir::reuse_ir::RegionRunOp></code>, <code>ReturnLike</code>, <code>Terminator</code></p><p>Interfaces: <code>RegionBranchTerminatorOpInterface</code></p><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>any type</td></tr></tbody></table><h3 id=reuse_irtokenalloc-reuse_irtokenallocop><code>reuse_ir.token.alloc</code> (reuse_ir::TokenAllocOp)&nbsp;<a class=headline-hash href=#reuse_irtokenalloc-reuse_irtokenallocop>¶</a></h3><p><em>Allocate memory token</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.token.alloc` `:` type($token) attr-dict
</code></pre><p><code>reuse_ir.alloc</code> allocates a memory token.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>reuse_ir<span class=p>.</span>alloc <span class=p>:</span> <span class=p>!</span>reuse_ir<span class=p>.</span>token<span class=p>&lt;</span>size<span class=p>:</span> <span class=m>16</span><span class=p>,</span> alignment<span class=p>:</span> <span class=m>8</span><span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=results-24>Results:&nbsp;<a class=headline-hash href=#results-24>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>token</code></td><td>ReuseIR Memory Token</td></tr></tbody></table><h3 id=reuse_irtokenensure-reuse_irtokenensureop><code>reuse_ir.token.ensure</code> (reuse_ir::TokenEnsureOp)&nbsp;<a class=headline-hash href=#reuse_irtokenensure-reuse_irtokenensureop>¶</a></h3><p><em>Ensure a nonnull token</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.token.ensure` `(` $nullableToken `:` type($nullableToken) `)` attr-dict `:` type($result)
</code></pre><p><code>reuse_ir.token.ensure</code> converts a possibly nullable token to a token by checking
the nullability and allocate memory on need.</p><h4 id=operands-25>Operands:&nbsp;<a class=headline-hash href=#operands-25>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>nullableToken</code></td><td>RcType of certain types</td></tr></tbody></table><h4 id=results-25>Results:&nbsp;<a class=headline-hash href=#results-25>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>ReuseIR Memory Token</td></tr></tbody></table><h3 id=reuse_irtokenfree-reuse_irtokenfreeop><code>reuse_ir.token.free</code> (reuse_ir::TokenFreeOp)&nbsp;<a class=headline-hash href=#reuse_irtokenfree-reuse_irtokenfreeop>¶</a></h3><p><em>Free memory token</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.token.free` `(` $token `:` type($token) `)` attr-dict
</code></pre><p><code>reuse_ir.token.free</code> deallocates a memory token.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>reuse_ir<span class=p>.</span>token<span class=p>.</span>free <span class=p>(</span><span class=nv>%x</span> <span class=p>:</span> <span class=p>!</span>reuse_ir<span class=p>.</span>token<span class=p>&lt;</span>size<span class=p>:</span> <span class=m>16</span><span class=p>,</span> alignment<span class=p>:</span> <span class=m>8</span><span class=p>&gt;)</span>
</span></span></code></pre></div><h4 id=operands-26>Operands:&nbsp;<a class=headline-hash href=#operands-26>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>token</code></td><td>ReuseIR Memory Token or RcType of certain types</td></tr></tbody></table><h3 id=reuse_irtokenrealloc-reuse_irtokenreallocop><code>reuse_ir.token.realloc</code> (reuse_ir::TokenReallocOp)&nbsp;<a class=headline-hash href=#reuse_irtokenrealloc-reuse_irtokenreallocop>¶</a></h3><p><em>Ensure a nonnull token</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.token.realloc` `(` $token `:` type($token) `)` attr-dict `-&gt;` type($result)
</code></pre><p><code>reuse_ir.token.realloc</code> converts a possibly nullable token to a token by checking
the nullability and reallocate the memory on need. Utimately, we should custom the
allocator to avoid memcpy if the content is not to be retained.</p><h4 id=operands-27>Operands:&nbsp;<a class=headline-hash href=#operands-27>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>token</code></td><td>ReuseIR Memory Token</td></tr></tbody></table><h4 id=results-26>Results:&nbsp;<a class=headline-hash href=#results-26>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>ReuseIR Memory Token</td></tr></tbody></table><h3 id=reuse_irtokenreinterpret-reuse_irtokenreinterpretop><code>reuse_ir.token.reinterpret</code> (reuse_ir::TokenReinterpretOp)&nbsp;<a class=headline-hash href=#reuse_irtokenreinterpret-reuse_irtokenreinterpretop>¶</a></h3><p><em>Reinterpret the token type</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.token.reinterpret` `(` $token `:` type($token) `)` attr-dict `:` type($result)
</code></pre><p><code>reuse_ir.token.reinterpret</code> reinterprets the token type.</p><h4 id=operands-28>Operands:&nbsp;<a class=headline-hash href=#operands-28>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>token</code></td><td>ReuseIR Memory Token</td></tr></tbody></table><h4 id=results-27>Results:&nbsp;<a class=headline-hash href=#results-27>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>ReuseIR Reference Type</td></tr></tbody></table><h3 id=reuse_irunionassemble-reuse_irunionassembleop><code>reuse_ir.union.assemble</code> (reuse_ir::UnionAssembleOp)&nbsp;<a class=headline-hash href=#reuse_irunionassemble-reuse_irunionassembleop>¶</a></h3><p><em>Create a new union object</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.union.assemble` `(` $tag `,` $field `)` attr-dict `:` functional-type(operands, results)
</code></pre><p><code>reuse_ir.union.assemble</code> creates a new union object.</p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tag</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr></table><h4 id=operands-29>Operands:&nbsp;<a class=headline-hash href=#operands-29>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>field</code></td><td>any type</td></tr></tbody></table><h4 id=results-28>Results:&nbsp;<a class=headline-hash href=#results-28>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>ReuseIR union type</td></tr></tbody></table><h3 id=reuse_irunionget_tag-reuse_iruniongettagop><code>reuse_ir.union.get_tag</code> (reuse_ir::UnionGetTagOp)&nbsp;<a class=headline-hash href=#reuse_irunionget_tag-reuse_iruniongettagop>¶</a></h3><p><em>Get the tag of the union type</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.union.get_tag` $unionRef attr-dict `:` type($unionRef) `-&gt;` type($tag)
</code></pre><p><code>reuse_ir.union.get_tag</code> gets the tag of the union type.</p><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-30>Operands:&nbsp;<a class=headline-hash href=#operands-30>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>unionRef</code></td><td>RcType of certain types</td></tr></tbody></table><h4 id=results-29>Results:&nbsp;<a class=headline-hash href=#results-29>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>tag</code></td><td>Integer-like type with unknown platform-dependent bit width</td></tr></tbody></table><h3 id=reuse_irunioninspect-reuse_irunioninspectop><code>reuse_ir.union.inspect</code> (reuse_ir::UnionInspectOp)&nbsp;<a class=headline-hash href=#reuse_irunioninspect-reuse_irunioninspectop>¶</a></h3><p><em>Inspect the union type</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.union.inspect` $unionRef `[` $index `]` attr-dict `:` type($unionRef) (`-&gt;` type($result)^)?
</code></pre><p><code>reuse_ir.union.inspect</code> inspects the union type and returns a reference to the type of
the given index. Such inspection is not checked in runtime.</p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr></table><h4 id=operands-31>Operands:&nbsp;<a class=headline-hash href=#operands-31>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>unionRef</code></td><td>RcType of certain types</td></tr></tbody></table><h4 id=results-30>Results:&nbsp;<a class=headline-hash href=#results-30>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>ReuseIR Reference Type</td></tr></tbody></table><h3 id=reuse_irunreachable-reuse_irunreachableop><code>reuse_ir.unreachable</code> (reuse_ir::UnreachableOp)&nbsp;<a class=headline-hash href=#reuse_irunreachable-reuse_irunreachableop>¶</a></h3><p><em>Notify the program that the code path is unreachable</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.unreachable` attr-dict (`:` type($result)^)?
</code></pre><p><code>reuse_ir.unreachable</code> notifies the program that the code path is unreachable.</p><h4 id=results-31>Results:&nbsp;<a class=headline-hash href=#results-31>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=reuse_irval2ref-reuse_irvaluetorefop><code>reuse_ir.val2ref</code> (reuse_ir::ValueToRefOp)&nbsp;<a class=headline-hash href=#reuse_irval2ref-reuse_irvaluetorefop>¶</a></h3><p><em>Promote a value to stack and get the reference</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `reuse_ir.val2ref` $value attr-dict `:` type($value) `-&gt;` type($result)
</code></pre><p><code>reuse_ir.val2ref</code> is used to promote a value to an alloca on stack.
For composite/union/array arguments passed as values:</p><ul><li>caller should either use <code>byval</code> ptr call convention: that is, spill the
value to stack pass its ref.</li><li>or when the struct is small enough, the value can be directly passed to
target function but inorder to decompose the the object, this operaton is
still needed.</li></ul><h4 id=operands-32>Operands:&nbsp;<a class=headline-hash href=#operands-32>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>any type</td></tr></tbody></table><h4 id=results-32>Results:&nbsp;<a class=headline-hash href=#results-32>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>ReuseIR Reference Type</td></tr></tbody></table><div class=edit-meta><br><a href=https://github.com/SchrodingerZhu/ReuseIR/tree/main/reuse-www/edit/main/website/content/dialect/code_docs/ReuseIROps.md class=edit-page><i class="fas fa-pen-square"></i> Edit on GitHub</a></div><nav class=pagination><a class="nav nav-prev" href=https://SchrodingerZhu.github.io/ReuseIR/dialect/code_docs/ReuseIRMangleInterface/ title=MangleInterface><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - MangleInterface</a>
<a class="nav nav-next" href=https://SchrodingerZhu.github.io/ReuseIR/dialect/code_docs/ReuseIRPasses/ title=Passes>Next - Passes <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://SchrodingerZhu.github.io/ReuseIR>Home</a></li><li><a href=https://SchrodingerZhu.github.io/ReuseIR/runtime/>Runtime</a></li><li><a href=https://SchrodingerZhu.github.io/ReuseIR/frontend/>Frontend</a></li><li class="parent has-sub-menu"><a href=https://SchrodingerZhu.github.io/ReuseIR/dialect/>Dialect<span class="mark opened">-</span></a><ul class=sub-menu><li class="parent has-sub-menu"><a href=https://SchrodingerZhu.github.io/ReuseIR/dialect/code_docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://SchrodingerZhu.github.io/ReuseIR/dialect/code_docs/ReuseIRCompositeLayoutInterface/>CompositeLayoutInterface</a></li><li><a href=https://SchrodingerZhu.github.io/ReuseIR/dialect/code_docs/ReuseIRDialect/>Dialect</a></li><li><a href=https://SchrodingerZhu.github.io/ReuseIR/dialect/code_docs/ReuseIRMangleInterface/>MangleInterface</a></li><li class=active><a href=https://SchrodingerZhu.github.io/ReuseIR/dialect/code_docs/ReuseIROps/>Ops</a></li><li><a href=https://SchrodingerZhu.github.io/ReuseIR/dialect/code_docs/ReuseIRPasses/>Passes</a></li><li><a href=https://SchrodingerZhu.github.io/ReuseIR/dialect/code_docs/ReuseIRTypes/>Types</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>