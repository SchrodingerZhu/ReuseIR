<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Types - ReuseIR</title><meta name=description content="Reuse Analysis in MLIR and Rust"><meta name=generator content="Hugo 0.119.0"><link href=https://SchrodingerZhu.github.io/ReuseIRindex.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://SchrodingerZhu.github.io/ReuseIR/dialect/code_docs/ReuseIRTypes/><link rel=stylesheet href=https://SchrodingerZhu.github.io/ReuseIR/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://SchrodingerZhu.github.io/ReuseIR/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://SchrodingerZhu.github.io/ReuseIR/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://SchrodingerZhu.github.io/ReuseIR/reuseir-logo-40x40.png width=40px align=absmiddle>
ReuseIR</div></h1><p class=description>Reuse Analysis in MLIR and Rust</p></header><div class=global-menu><nav><ul><li class=parent><a href=https://github.com/SchrodingerZhu/ReuseIR/issues>Issues<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://github.com/SchrodingerZhu/ReuseIR/issues/new/choose>Report issue</a></li></ul></li><li class=parent><a href=https://github.com/SchrodingerZhu/ReuseIR>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://github.com/SchrodingerZhu/ReuseIR/tree/main/reuse-runtime>Runtime</a></li><li class=child><a href=https://github.com/SchrodingerZhu/ReuseIR/tree/main/reuse-frontend>Frontend</a></li><li class=child><a href=https://github.com/SchrodingerZhu/ReuseIR/tree/main/reuse-mlir>Dialect</a></li></ul></li><li><a href=https://github.com/SchrodingerZhu/ReuseIR/releases>Releases</a></li></ul></nav></div><div class=content-container><main><h1>Types</h1><h3 id=bfloat16type>BFloat16Type&nbsp;<a class=headline-hash href=#bfloat16type>¶</a></h3><p>bfloat16 floating-point type</p><h3 id=complextype>ComplexType&nbsp;<a class=headline-hash href=#complextype>¶</a></h3><p>Complex number with a parameterized element type</p><p>Syntax:</p><pre tabindex=0><code>complex-type ::= `complex` `&lt;` type `&gt;`
</code></pre><p>The value of <code>complex</code> type represents a complex number with a parameterized
element type, which is composed of a real and imaginary value of that
element type. The element must be a floating point or integer scalar type.</p><h4 id=example>Example:&nbsp;<a class=headline-hash href=#example>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>complex<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>complex<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=parameters>Parameters:&nbsp;<a class=headline-hash href=#parameters>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>Type</code></td><td></td></tr></tbody></table><h3 id=float6e2m3fntype>Float6E2M3FNType&nbsp;<a class=headline-hash href=#float6e2m3fntype>¶</a></h3><p>6-bit floating point with 2-bit exponent and 3-bit mantissa</p><p>An 6-bit floating point type with 1 sign bit, 2 bits exponent and 3 bits
mantissa. This is not a standard type as defined by IEEE-754, but it
follows similar conventions with the following characteristics:</p><ul><li>bit encoding: S1E2M3</li><li>exponent bias: 1</li><li>infinities: Not supported</li><li>NaNs: Not supported</li><li>denormals when exponent is 0</li></ul><p>Open Compute Project (OCP) microscaling formats (MX) specification:
<a href=https://www.opencompute.org/documents/ocp-microscaling-formats-mx-v1-0-spec-final-pdf>https://www.opencompute.org/documents/ocp-microscaling-formats-mx-v1-0-spec-final-pdf</a></p><h3 id=float6e3m2fntype>Float6E3M2FNType&nbsp;<a class=headline-hash href=#float6e3m2fntype>¶</a></h3><p>6-bit floating point with 3-bit exponent and 2-bit mantissa</p><p>An 6-bit floating point type with 1 sign bit, 3 bits exponent and 2 bits
mantissa. This is not a standard type as defined by IEEE-754, but it
follows similar conventions with the following characteristics:</p><ul><li>bit encoding: S1E3M2</li><li>exponent bias: 3</li><li>infinities: Not supported</li><li>NaNs: Not supported</li><li>denormals when exponent is 0</li></ul><p>Open Compute Project (OCP) microscaling formats (MX) specification:
<a href=https://www.opencompute.org/documents/ocp-microscaling-formats-mx-v1-0-spec-final-pdf>https://www.opencompute.org/documents/ocp-microscaling-formats-mx-v1-0-spec-final-pdf</a></p><h3 id=float8e3m4type>Float8E3M4Type&nbsp;<a class=headline-hash href=#float8e3m4type>¶</a></h3><p>8-bit floating point with 3 bits exponent and 4 bit mantissa</p><p>An 8-bit floating point type with 1 sign bit, 3 bits exponent and 4 bits
mantissa. This is not a standard type as defined by IEEE-754, but it
follows similar conventions with the following characteristics:</p><ul><li>bit encoding: S1E3M4</li><li>exponent bias: 3</li><li>infinities: supported with exponent set to all 1s and mantissa 0s</li><li>NaNs: supported with exponent bits set to all 1s and mantissa values of
{0,1}⁴ except S.111.0000</li><li>denormals when exponent is 0</li></ul><h3 id=float8e4m3type>Float8E4M3Type&nbsp;<a class=headline-hash href=#float8e4m3type>¶</a></h3><p>8-bit floating point with 3 bit mantissa</p><p>An 8-bit floating point type with 1 sign bit, 4 bits exponent and 3 bits
mantissa. This is not a standard type as defined by IEEE-754, but it
follows similar conventions with the following characteristics:</p><ul><li>bit encoding: S1E4M3</li><li>exponent bias: 7</li><li>infinities: supported with exponent set to all 1s and mantissa 0s</li><li>NaNs: supported with exponent bits set to all 1s and mantissa of
(001, 010, 011, 100, 101, 110, 111)</li><li>denormals when exponent is 0</li></ul><h3 id=float8e4m3b11fnuztype>Float8E4M3B11FNUZType&nbsp;<a class=headline-hash href=#float8e4m3b11fnuztype>¶</a></h3><p>8-bit floating point with 3 bit mantissa</p><p>An 8-bit floating point type with 1 sign bit, 4 bits exponent and 3 bits
mantissa. This is not a standard type as defined by IEEE-754, but it follows
similar conventions, with the exception that there are no infinity values,
no negative zero, and only one NaN representation. This type has the
following characteristics:</p><ul><li>bit encoding: S1E4M3</li><li>exponent bias: 11</li><li>infinities: Not supported</li><li>NaNs: Supported with sign bit set to 1, exponent bits and mantissa bits set to all 0s</li><li>denormals when exponent is 0</li></ul><p>Related to:
<a href=https://dl.acm.org/doi/10.5555/3454287.3454728>https://dl.acm.org/doi/10.5555/3454287.3454728</a></p><h3 id=float8e4m3fntype>Float8E4M3FNType&nbsp;<a class=headline-hash href=#float8e4m3fntype>¶</a></h3><p>8-bit floating point with 3 bit mantissa</p><p>An 8-bit floating point type with 1 sign bit, 4 bits exponent and 3 bits
mantissa. This is not a standard type as defined by IEEE-754, but it follows
similar conventions, with the exception that there are no infinity values
and only two NaN representations. This type has the following
characteristics:</p><ul><li>bit encoding: S1E4M3</li><li>exponent bias: 7</li><li>infinities: Not supported</li><li>NaNs: supported with exponent bits and mantissa bits set to all 1s</li><li>denormals when exponent is 0</li></ul><p>Described in:
<a href=https://arxiv.org/abs/2209.05433>https://arxiv.org/abs/2209.05433</a></p><h3 id=float8e4m3fnuztype>Float8E4M3FNUZType&nbsp;<a class=headline-hash href=#float8e4m3fnuztype>¶</a></h3><p>8-bit floating point with 3 bit mantissa</p><p>An 8-bit floating point type with 1 sign bit, 4 bits exponent and 3 bits
mantissa. This is not a standard type as defined by IEEE-754, but it follows
similar conventions, with the exception that there are no infinity values,
no negative zero, and only one NaN representation. This type has the
following characteristics:</p><ul><li>bit encoding: S1E4M3</li><li>exponent bias: 8</li><li>infinities: Not supported</li><li>NaNs: Supported with sign bit set to 1, exponent bits and mantissa bits set to all 0s</li><li>denormals when exponent is 0</li></ul><p>Described in:
<a href=https://arxiv.org/abs/2209.05433>https://arxiv.org/abs/2209.05433</a></p><h3 id=float8e5m2type>Float8E5M2Type&nbsp;<a class=headline-hash href=#float8e5m2type>¶</a></h3><p>8-bit floating point with 2 bit mantissa</p><p>An 8-bit floating point type with 1 sign bit, 5 bits exponent and 2 bits
mantissa. This is not a standard type as defined by IEEE-754, but it
follows similar conventions with the following characteristics:</p><ul><li>bit encoding: S1E5M2</li><li>exponent bias: 15</li><li>infinities: supported with exponent set to all 1s and mantissa 0s</li><li>NaNs: supported with exponent bits set to all 1s and mantissa of
(01, 10, or 11)</li><li>denormals when exponent is 0</li></ul><p>Described in:
<a href=https://arxiv.org/abs/2209.05433>https://arxiv.org/abs/2209.05433</a></p><h3 id=float8e5m2fnuztype>Float8E5M2FNUZType&nbsp;<a class=headline-hash href=#float8e5m2fnuztype>¶</a></h3><p>8-bit floating point with 2 bit mantissa</p><p>An 8-bit floating point type with 1 sign bit, 5 bits exponent and 2 bits
mantissa. This is not a standard type as defined by IEEE-754, but it follows
similar conventions, with the exception that there are no infinity values,
no negative zero, and only one NaN representation. This type has the
following characteristics:</p><ul><li>bit encoding: S1E5M2</li><li>exponent bias: 16</li><li>infinities: Not supported</li><li>NaNs: Supported with sign bit set to 1, exponent bits and mantissa bits set to all 0s</li><li>denormals when exponent is 0</li></ul><p>Described in:
<a href=https://arxiv.org/abs/2206.02915>https://arxiv.org/abs/2206.02915</a></p><h3 id=float16type>Float16Type&nbsp;<a class=headline-hash href=#float16type>¶</a></h3><p>16-bit floating-point type</p><h3 id=float32type>Float32Type&nbsp;<a class=headline-hash href=#float32type>¶</a></h3><p>32-bit floating-point type</p><h3 id=float64type>Float64Type&nbsp;<a class=headline-hash href=#float64type>¶</a></h3><p>64-bit floating-point type</p><h3 id=float80type>Float80Type&nbsp;<a class=headline-hash href=#float80type>¶</a></h3><p>80-bit floating-point type</p><h3 id=float128type>Float128Type&nbsp;<a class=headline-hash href=#float128type>¶</a></h3><p>128-bit floating-point type</p><h3 id=floattf32type>FloatTF32Type&nbsp;<a class=headline-hash href=#floattf32type>¶</a></h3><p>TF32 floating-point type</p><h3 id=functiontype>FunctionType&nbsp;<a class=headline-hash href=#functiontype>¶</a></h3><p>Map from a list of inputs to a list of results</p><p>Syntax:</p><pre tabindex=0><code>// Function types may have multiple results.
function-result-type ::= type-list-parens | non-function-type
function-type ::= type-list-parens `-&gt;` function-result-type
</code></pre><p>The function type can be thought of as a function signature. It consists of
a list of formal parameter types and a list of formal result types.</p><h4 id=example-1>Example:&nbsp;<a class=headline-hash href=#example-1>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@add_one</span><span class=p>(</span><span class=nv>%arg0</span> <span class=p>:</span> <span class=k>i64</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%c1</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>1</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> arith<span class=p>.</span>addi <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%c1</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>  <span class=kt>return</span> <span class=nv>%0</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=parameters-1>Parameters:&nbsp;<a class=headline-hash href=#parameters-1>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>inputs</td><td style=text-align:center><code>ArrayRef&lt;Type></code></td><td></td></tr><tr><td style=text-align:center>results</td><td style=text-align:center><code>ArrayRef&lt;Type></code></td><td></td></tr></tbody></table><h3 id=indextype>IndexType&nbsp;<a class=headline-hash href=#indextype>¶</a></h3><p>Integer-like type with unknown platform-dependent bit width</p><p>Syntax:</p><pre tabindex=0><code>// Target word-sized integer.
index-type ::= `index`
</code></pre><p>The index type is a signless integer whose size is equal to the natural
machine word of the target (
<a href=../../Rationale/Rationale/#integer-signedness-semantics>rationale</a> )
and is used by the affine constructs in MLIR.</p><p><strong>Rationale:</strong> integers of platform-specific bit widths are practical to
express sizes, dimensionalities and subscripts.</p><h3 id=integertype>IntegerType&nbsp;<a class=headline-hash href=#integertype>¶</a></h3><p>Integer type with arbitrary precision up to a fixed limit</p><p>Syntax:</p><pre tabindex=0><code>// Sized integers like i1, i4, i8, i16, i32.
signed-integer-type ::= `si` [1-9][0-9]*
unsigned-integer-type ::= `ui` [1-9][0-9]*
signless-integer-type ::= `i` [1-9][0-9]*
integer-type ::= signed-integer-type |
                 unsigned-integer-type |
                 signless-integer-type
</code></pre><p>Integer types have a designated bit width and may optionally have signedness
semantics.</p><p><strong>Rationale:</strong> low precision integers (like <code>i2</code>, <code>i4</code> etc) are useful for
low-precision inference chips, and arbitrary precision integers are useful
for hardware synthesis (where a 13 bit multiplier is a lot cheaper/smaller
than a 16 bit one).</p><h4 id=parameters-2>Parameters:&nbsp;<a class=headline-hash href=#parameters-2>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>width</td><td style=text-align:center><code>unsigned</code></td><td></td></tr><tr><td style=text-align:center>signedness</td><td style=text-align:center><code>SignednessSemantics</code></td><td></td></tr></tbody></table><h3 id=memreftype>MemRefType&nbsp;<a class=headline-hash href=#memreftype>¶</a></h3><p>Shaped reference to a region of memory</p><p>Syntax:</p><pre tabindex=0><code>layout-specification ::= attribute-value
memory-space ::= attribute-value
memref-type ::= `memref` `&lt;` dimension-list-ranked type
                (`,` layout-specification)? (`,` memory-space)? `&gt;`
</code></pre><p>A <code>memref</code> type is a reference to a region of memory (similar to a buffer
pointer, but more powerful). The buffer pointed to by a memref can be
allocated, aliased and deallocated. A memref can be used to read and write
data from/to the memory region which it references. Memref types use the
same shape specifier as tensor types. Note that <code>memref&lt;f32></code>,
<code>memref&lt;0 x f32></code>, <code>memref&lt;1 x 0 x f32></code>, and <code>memref&lt;0 x 1 x f32></code> are all
different types.</p><p>A <code>memref</code> is allowed to have an unknown rank (e.g. <code>memref&lt;*xf32></code>). The
purpose of unranked memrefs is to allow external library functions to
receive memref arguments of any rank without versioning the functions based
on the rank. Other uses of this type are disallowed or will have undefined
behavior.</p><p>Are accepted as elements:</p><ul><li>built-in integer types;</li><li>built-in index type;</li><li>built-in floating point types;</li><li>built-in vector types with elements of the above types;</li><li>another memref type;</li><li>any other type implementing <code>MemRefElementTypeInterface</code>.</li></ul><h5 id=layout>Layout&nbsp;<a class=headline-hash href=#layout>¶</a></h5><p>A memref may optionally have a layout that indicates how indices are
transformed from the multi-dimensional form into a linear address. The
layout must avoid internal aliasing, i.e., two distinct tuples of
<em>in-bounds</em> indices must be pointing to different elements in memory. The
layout is an attribute that implements <code>MemRefLayoutAttrInterface</code>. The
bulitin dialect offers two kinds of layouts: strided and affine map, each
of which is available as an attribute. Other attributes may be used to
represent the layout as long as they can be converted to a
<a href=Affine.md/#semi-affine-maps>semi-affine map</a> and implement the required
interface. Users of memref are expected to fallback to the affine
representation when handling unknown memref layouts. Multi-dimensional
affine forms are interpreted in <em>row-major</em> fashion.</p><p>In absence of an explicit layout, a memref is considered to have a
multi-dimensional identity affine map layout. Identity layout maps do not
contribute to the MemRef type identification and are discarded on
construction. That is, a type with an explicit identity map is
<code>memref&lt;?x?xf32, (i,j)->(i,j)></code> is strictly the same as the one without a
layout, <code>memref&lt;?x?xf32></code>.</p><h5 id=affine-map-layout>Affine Map Layout&nbsp;<a class=headline-hash href=#affine-map-layout>¶</a></h5><p>The layout may be represented directly as an affine map from the index space
to the storage space. For example, the following figure shows an index map
which maps a 2-dimensional index from a 2x2 index space to a 3x3 index
space, using symbols <code>S0</code> and <code>S1</code> as offsets.</p><p><img src=/includes/img/index-map.svg alt="Index Map Example"></p><p>Semi-affine maps are sufficiently flexible to represent a wide variety of
dense storage layouts, including row- and column-major and tiled:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// MxN matrix stored in row major layout in memory:
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>#layout_map_row_major</span> <span class=p>=</span> <span class=p>(</span>i<span class=p>,</span> j<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>i<span class=p>,</span> j<span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// MxN matrix stored in column major layout in memory:
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>#layout_map_col_major</span> <span class=p>=</span> <span class=p>(</span>i<span class=p>,</span> j<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>j<span class=p>,</span> i<span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// MxN matrix stored in a 2-d blocked/tiled layout with 64x64 tiles.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>#layout_tiled</span> <span class=p>=</span> <span class=p>(</span>i<span class=p>,</span> j<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>i floordiv <span class=m>64</span><span class=p>,</span> j floordiv <span class=m>64</span><span class=p>,</span> i mod <span class=m>64</span><span class=p>,</span> j mod <span class=m>64</span><span class=p>)</span>
</span></span></code></pre></div><h5 id=strided-layout>Strided Layout&nbsp;<a class=headline-hash href=#strided-layout>¶</a></h5><p>Memref layout can be expressed using strides to encode the distance, in
number of elements, in (linear) memory between successive entries along a
particular dimension. For example, a row-major strided layout for
<code>memref&lt;2x3x4xf32></code> is <code>strided&lt;[12, 4, 1]></code>, where the last dimension is
contiguous as indicated by the unit stride and the remaining strides are
products of the sizes of faster-variying dimensions. Strided layout can also
express non-contiguity, e.g., <code>memref&lt;2x3, strided&lt;[6, 2]>></code> only accesses
even elements of the dense consecutive storage along the innermost
dimension.</p><p>The strided layout supports an optional <em>offset</em> that indicates the
distance, in the number of elements, between the beginning of the memref
and the first accessed element. When omitted, the offset is considered to
be zero. That is, <code>memref&lt;2, strided&lt;[2], offset: 0>></code> and
<code>memref&lt;2, strided&lt;[2]>></code> are strictly the same type.</p><p>Both offsets and strides may be <em>dynamic</em>, that is, unknown at compile time.
This is represented by using a question mark (<code>?</code>) instead of the value in
the textual form of the IR.</p><p>The strided layout converts into the following canonical one-dimensional
affine form through explicit linearization:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> <span class=p>...</span> dN<span class=p>)[</span>offset<span class=p>,</span> stride0<span class=p>,</span> <span class=p>...</span> strideN<span class=p>]</span> <span class=p>-&gt;</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span>offset <span class=err>+</span> d0 <span class=p>*</span> stride0 <span class=err>+</span> <span class=p>...</span> dN <span class=p>*</span> strideN<span class=p>)&gt;</span>
</span></span></code></pre></div><p>Therefore, it is never subject to the implicit row-major layout
interpretation.</p><h5 id=codegen-of-unranked-memref>Codegen of Unranked Memref&nbsp;<a class=headline-hash href=#codegen-of-unranked-memref>¶</a></h5><p>Using unranked memref in codegen besides the case mentioned above is highly
discouraged. Codegen is concerned with generating loop nests and specialized
instructions for high-performance, unranked memref is concerned with hiding
the rank and thus, the number of enclosing loops required to iterate over
the data. However, if there is a need to code-gen unranked memref, one
possible path is to cast into a static ranked type based on the dynamic
rank. Another possible path is to emit a single while loop conditioned on a
linear index and perform delinearization of the linear index to a dynamic
array containing the (unranked) indices. While this is possible, it is
expected to not be a good idea to perform this during codegen as the cost
of the translations is expected to be prohibitive and optimizations at this
level are not expected to be worthwhile. If expressiveness is the main
concern, irrespective of performance, passing unranked memrefs to an
external C++ library and implementing rank-agnostic logic there is expected
to be significantly simpler.</p><p>Unranked memrefs may provide expressiveness gains in the future and help
bridge the gap with unranked tensors. Unranked memrefs will not be expected
to be exposed to codegen but one may query the rank of an unranked memref
(a special op will be needed for this purpose) and perform a switch and cast
to a ranked memref as a prerequisite to codegen.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// With static ranks, we need a function for each possible argument type
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%A</span> <span class=p>=</span> alloc<span class=p>()</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%B</span> <span class=p>=</span> alloc<span class=p>()</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x64x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>call <span class=nf>@helper_2D</span><span class=p>(</span><span class=nv>%A</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x</span><span class=k>f32</span><span class=p>&gt;)-&gt;()</span>
</span></span><span class=line><span class=cl>call <span class=nf>@helper_3D</span><span class=p>(</span><span class=nv>%B</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x64x</span><span class=k>f32</span><span class=p>&gt;)-&gt;()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// With unknown rank, the functions can be unified under one unranked type
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%A</span> <span class=p>=</span> alloc<span class=p>()</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%B</span> <span class=p>=</span> alloc<span class=p>()</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x64x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=c>// Remove rank info
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%A_u</span> <span class=p>=</span> <span class=kt>memref</span>_cast <span class=nv>%A</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=kt>memref</span><span class=p>&lt;*</span>xf32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%B_u</span> <span class=p>=</span> <span class=kt>memref</span>_cast <span class=nv>%B</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x64x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=kt>memref</span><span class=p>&lt;*</span>xf32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=c>// call same function with dynamic ranks
</span></span></span><span class=line><span class=cl><span class=c></span>call <span class=nf>@helper</span><span class=p>(</span><span class=nv>%A_u</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;*</span>xf32<span class=p>&gt;)-&gt;()</span>
</span></span><span class=line><span class=cl>call <span class=nf>@helper</span><span class=p>(</span><span class=nv>%B_u</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;*</span>xf32<span class=p>&gt;)-&gt;()</span>
</span></span></code></pre></div><p>The core syntax and representation of a layout specification is a
<a href=Affine.md/#semi-affine-maps>semi-affine map</a>. Additionally,
syntactic sugar is supported to make certain layout specifications more
intuitive to read. For the moment, a <code>memref</code> supports parsing a strided
form which is converted to a semi-affine map automatically.</p><p>The memory space of a memref is specified by a target-specific attribute.
It might be an integer value, string, dictionary or custom dialect attribute.
The empty memory space (attribute is None) is target specific.</p><p>The notionally dynamic value of a memref value includes the address of the
buffer allocated, as well as the symbols referred to by the shape, layout
map, and index maps.</p><p>Examples of memref static type</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Identity index/layout map
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>#identity</span> <span class=p>=</span> affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>,</span> d1<span class=p>)&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Column major layout.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>#col_major</span> <span class=p>=</span> affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>,</span> d2<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d2<span class=p>,</span> d1<span class=p>,</span> d0<span class=p>)&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// A 2-d tiled layout with tiles of size 128 x 256.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>#tiled_2d_128x256</span> <span class=p>=</span> affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 div <span class=m>128</span><span class=p>,</span> d1 div <span class=m>256</span><span class=p>,</span> d0 mod <span class=m>128</span><span class=p>,</span> d1 mod <span class=m>256</span><span class=p>)&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// A tiled data layout with non-constant tile sizes.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>#tiled_dynamic</span> <span class=p>=</span> affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>)[</span>s0<span class=p>,</span> s1<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 floordiv s0<span class=p>,</span> d1 floordiv s1<span class=p>,</span>
</span></span><span class=line><span class=cl>                             d0 mod s0<span class=p>,</span> d1 mod s1<span class=p>)&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// A layout that yields a padding on two at either end of the minor dimension.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>#padded</span> <span class=p>=</span> affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0<span class=p>,</span> <span class=p>(</span>d1 <span class=err>+</span> <span class=m>2</span><span class=p>)</span> floordiv <span class=m>2</span><span class=p>,</span> <span class=p>(</span>d1 <span class=err>+</span> <span class=m>2</span><span class=p>)</span> mod <span class=m>2</span><span class=p>)&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// The dimension list &#34;16x32&#34; defines the following 2D index space:
</span></span></span><span class=line><span class=cl><span class=c>//
</span></span></span><span class=line><span class=cl><span class=c>//   { (i, j) : 0 &lt;= i &lt; 16, 0 &lt;= j &lt; 32 }
</span></span></span><span class=line><span class=cl><span class=c>//
</span></span></span><span class=line><span class=cl><span class=c></span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x32x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#identity</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// The dimension list &#34;16x4x?&#34; defines the following 3D index space:
</span></span></span><span class=line><span class=cl><span class=c>//
</span></span></span><span class=line><span class=cl><span class=c>//   { (i, j, k) : 0 &lt;= i &lt; 16, 0 &lt;= j &lt; 4, 0 &lt;= k &lt; N }
</span></span></span><span class=line><span class=cl><span class=c>//
</span></span></span><span class=line><span class=cl><span class=c>// where N is a symbol which represents the runtime value of the size of
</span></span></span><span class=line><span class=cl><span class=c>// the third dimension.
</span></span></span><span class=line><span class=cl><span class=c>//
</span></span></span><span class=line><span class=cl><span class=c>// %N here binds to the size of the third dimension.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%A</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%N</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x4x?x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#col_major</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// A 2-d dynamic shaped memref that also has a dynamically sized tiled
</span></span></span><span class=line><span class=cl><span class=c>// layout. The memref index space is of size %M x %N, while %B1 and %B2
</span></span></span><span class=line><span class=cl><span class=c>// bind to the symbols s0, s1 respectively of the layout map #tiled_dynamic.
</span></span></span><span class=line><span class=cl><span class=c>// Data tiles of size %B1 x %B2 in the logical space will be stored
</span></span></span><span class=line><span class=cl><span class=c>// contiguously in memory. The allocation size will be
</span></span></span><span class=line><span class=cl><span class=c>// (%M ceildiv %B1) * %B1 * (%N ceildiv %B2) * %B2 f32 elements.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%T</span> <span class=p>=</span> alloc<span class=p>(</span><span class=nv>%M</span><span class=p>,</span> <span class=nv>%N</span><span class=p>)</span> <span class=p>[</span><span class=nv>%B1</span><span class=p>,</span> <span class=nv>%B2</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#tiled_dynamic</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// A memref that has a two-element padding at either end. The allocation
</span></span></span><span class=line><span class=cl><span class=c>// size will fit 16 * 64 float elements of data.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%P</span> <span class=p>=</span> alloc<span class=p>()</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>16x64x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#padded</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Affine map with symbol &#39;s0&#39; used as offset for the first dimension.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>#imapS</span> <span class=p>=</span> affine_map<span class=p>&lt;(</span>d0<span class=p>,</span> d1<span class=p>)</span> <span class=p>[</span>s0<span class=p>]</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 <span class=err>+</span> s0<span class=p>,</span> d1<span class=p>)&gt;</span>
</span></span><span class=line><span class=cl><span class=c>// Allocate memref and bind the following symbols:
</span></span></span><span class=line><span class=cl><span class=c>// &#39;%n&#39; is bound to the dynamic second dimension of the memref type.
</span></span></span><span class=line><span class=cl><span class=c>// &#39;%o&#39; is bound to the symbol &#39;s0&#39; in the affine map of the memref type.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%n</span> <span class=p>=</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=nv>%o</span> <span class=p>=</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=nv>%A</span> <span class=p>=</span> alloc <span class=p>(</span><span class=nv>%n</span><span class=p>)[</span><span class=nv>%o</span><span class=p>]</span> <span class=p>:</span> <span class=p>&lt;</span><span class=m>16x?x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#imapS</span><span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-3>Parameters:&nbsp;<a class=headline-hash href=#parameters-3>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>shape</td><td style=text-align:center><code>::llvm::ArrayRef&lt;int64_t></code></td><td></td></tr><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>Type</code></td><td></td></tr><tr><td style=text-align:center>layout</td><td style=text-align:center><code>MemRefLayoutAttrInterface</code></td><td></td></tr><tr><td style=text-align:center>memorySpace</td><td style=text-align:center><code>Attribute</code></td><td></td></tr></tbody></table><h3 id=nonetype>NoneType&nbsp;<a class=headline-hash href=#nonetype>¶</a></h3><p>A unit type</p><p>Syntax:</p><pre tabindex=0><code>none-type ::= `none`
</code></pre><p>NoneType is a unit type, i.e. a type with exactly one possible value, where
its value does not have a defined dynamic representation.</p><h4 id=example-2>Example:&nbsp;<a class=headline-hash href=#example-2>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@none_type</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%none_val</span> <span class=p>=</span> <span class=s>&#34;foo.unknown_op&#34;</span><span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> none
</span></span><span class=line><span class=cl>  <span class=kt>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=opaquetype>OpaqueType&nbsp;<a class=headline-hash href=#opaquetype>¶</a></h3><p>Type of a non-registered dialect</p><p>Syntax:</p><pre tabindex=0><code>opaque-type ::= `opaque` `&lt;` type `&gt;`
</code></pre><p>Opaque types represent types of non-registered dialects. These are types
represented in their raw string form, and can only usefully be tested for
type equality.</p><h4 id=example-3>Example:&nbsp;<a class=headline-hash href=#example-3>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>opaque<span class=p>&lt;</span><span class=s>&#34;llvm&#34;</span><span class=p>,</span> <span class=s>&#34;struct&lt;(i32, float)&gt;&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>opaque<span class=p>&lt;</span><span class=s>&#34;pdl&#34;</span><span class=p>,</span> <span class=s>&#34;value&#34;</span><span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-4>Parameters:&nbsp;<a class=headline-hash href=#parameters-4>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>dialectNamespace</td><td style=text-align:center><code>StringAttr</code></td><td></td></tr><tr><td style=text-align:center>typeData</td><td style=text-align:center><code>::llvm::StringRef</code></td><td></td></tr></tbody></table><h3 id=rankedtensortype>RankedTensorType&nbsp;<a class=headline-hash href=#rankedtensortype>¶</a></h3><p>Multi-dimensional array with a fixed number of dimensions</p><p>Syntax:</p><pre tabindex=0><code>tensor-type ::= `tensor` `&lt;` dimension-list type (`,` encoding)? `&gt;`
dimension-list ::= (dimension `x`)*
dimension ::= `?` | decimal-literal
encoding ::= attribute-value
</code></pre><p>Values with tensor type represents aggregate N-dimensional data values, and
have a known element type and a fixed rank with a list of dimensions. Each
dimension may be a static non-negative decimal constant or be dynamically
determined (indicated by <code>?</code>).</p><p>The runtime representation of the MLIR tensor type is intentionally
abstracted - you cannot control layout or get a pointer to the data. For
low level buffer access, MLIR has a
<a href=#memreftype><code>memref</code> type</a>. This
abstracted runtime representation holds both the tensor data values as well
as information about the (potentially dynamic) shape of the tensor. The
<a href=MemRef.md/#memrefdim-mlirmemrefdimop><code>dim</code> operation</a> returns the size of a
dimension from a value of tensor type.</p><p>The <code>encoding</code> attribute provides additional information on the tensor.
An empty attribute denotes a straightforward tensor without any specific
structure. But particular properties, like sparsity or other specific
characteristics of the data of the tensor can be encoded through this
attribute. The semantics are defined by a type and attribute interface
and must be respected by all passes that operate on tensor types.
TODO: provide this interface, and document it further.</p><p>Note: hexadecimal integer literals are not allowed in tensor type
declarations to avoid confusion between <code>0xf32</code> and <code>0 x f32</code>. Zero sizes
are allowed in tensors and treated as other sizes, e.g.,
<code>tensor&lt;0 x 1 x i32></code> and <code>tensor&lt;1 x 0 x i32></code> are different types. Since
zero sizes are not allowed in some other types, such tensors should be
optimized away before lowering tensors to vectors.</p><h4 id=example-4>Example:&nbsp;<a class=headline-hash href=#example-4>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Known rank but unknown dimensions.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>? x</span> <span class=m>? x</span> <span class=m>? x</span> <span class=m>? x</span> <span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Partially known dimensions.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>? x</span> <span class=m>? x</span> <span class=m>13 x</span> <span class=m>? x</span> <span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Full static shape.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>17 x</span> <span class=m>4 x</span> <span class=m>13 x</span> <span class=m>4 x</span> <span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Tensor with rank zero. Represents a scalar.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=kt>tensor</span><span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Zero-element dimensions are allowed.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>0</span> <span class=p>x</span> <span class=m>42 x</span> <span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Zero-element tensor of f32 type (hexadecimal literals not allowed here).
</span></span></span><span class=line><span class=cl><span class=c></span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>0xf32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Tensor with an encoding attribute (where #ENCODING is a named alias).
</span></span></span><span class=line><span class=cl><span class=c></span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f64</span><span class=p>,</span> <span class=nv>#ENCODING</span><span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-5>Parameters:&nbsp;<a class=headline-hash href=#parameters-5>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>shape</td><td style=text-align:center><code>::llvm::ArrayRef&lt;int64_t></code></td><td></td></tr><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>Type</code></td><td></td></tr><tr><td style=text-align:center>encoding</td><td style=text-align:center><code>Attribute</code></td><td></td></tr></tbody></table><h3 id=tupletype>TupleType&nbsp;<a class=headline-hash href=#tupletype>¶</a></h3><p>Fixed-sized collection of other types</p><p>Syntax:</p><pre tabindex=0><code>tuple-type ::= `tuple` `&lt;` (type ( `,` type)*)? `&gt;`
</code></pre><p>The value of <code>tuple</code> type represents a fixed-size collection of elements,
where each element may be of a different type.</p><p><strong>Rationale:</strong> Though this type is first class in the type system, MLIR
provides no standard operations for operating on <code>tuple</code> types
(
<a href=../../Rationale/Rationale/#tuple-types>rationale</a>).</p><h4 id=example-5>Example:&nbsp;<a class=headline-hash href=#example-5>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Empty tuple.
</span></span></span><span class=line><span class=cl><span class=c></span>tuple<span class=p>&lt;&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Single element
</span></span></span><span class=line><span class=cl><span class=c></span>tuple<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Many elements.
</span></span></span><span class=line><span class=cl><span class=c></span>tuple<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> <span class=k>f32</span><span class=p>,</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=k>i1</span><span class=p>&gt;,</span> <span class=k>i5</span><span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-6>Parameters:&nbsp;<a class=headline-hash href=#parameters-6>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>types</td><td style=text-align:center><code>ArrayRef&lt;Type></code></td><td></td></tr></tbody></table><h3 id=unrankedmemreftype>UnrankedMemRefType&nbsp;<a class=headline-hash href=#unrankedmemreftype>¶</a></h3><p>Shaped reference, with unknown rank, to a region of memory</p><p>Syntax:</p><pre tabindex=0><code>unranked-memref-type ::= `memref` `&lt;*x` type (`,` memory-space)? `&gt;`
memory-space ::= attribute-value
</code></pre><p>A <code>memref</code> type with an unknown rank (e.g. <code>memref&lt;*xf32></code>). The purpose of
unranked memrefs is to allow external library functions to receive memref
arguments of any rank without versioning the functions based on the rank.
Other uses of this type are disallowed or will have undefined behavior.</p><p>See
<a href=#memreftype>MemRefType</a> for more information on
memref types.</p><h4 id=examples>Examples:&nbsp;<a class=headline-hash href=#examples>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=kt>memref</span><span class=p>&lt;*</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// An unranked memref with a memory space of 10.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=kt>memref</span><span class=p>&lt;*</span><span class=k>f32</span><span class=p>,</span> <span class=m>10</span><span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-7>Parameters:&nbsp;<a class=headline-hash href=#parameters-7>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>Type</code></td><td></td></tr><tr><td style=text-align:center>memorySpace</td><td style=text-align:center><code>Attribute</code></td><td></td></tr></tbody></table><h3 id=unrankedtensortype>UnrankedTensorType&nbsp;<a class=headline-hash href=#unrankedtensortype>¶</a></h3><p>Multi-dimensional array with unknown dimensions</p><p>Syntax:</p><pre tabindex=0><code>tensor-type ::= `tensor` `&lt;` `*` `x` type `&gt;`
</code></pre><p>An unranked tensor is a type of tensor in which the set of dimensions have
unknown rank. See
<a href=#rankedtensortype>RankedTensorType</a>
for more information on tensor types.</p><h4 id=examples-1>Examples:&nbsp;<a class=headline-hash href=#examples-1>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=kt>tensor</span><span class=p>&lt;*</span>xf32<span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-8>Parameters:&nbsp;<a class=headline-hash href=#parameters-8>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>Type</code></td><td></td></tr></tbody></table><h3 id=vectortype>VectorType&nbsp;<a class=headline-hash href=#vectortype>¶</a></h3><p>Multi-dimensional SIMD vector type</p><p>Syntax:</p><pre tabindex=0><code>vector-type ::= `vector` `&lt;` vector-dim-list vector-element-type `&gt;`
vector-element-type ::= float-type | integer-type | index-type
vector-dim-list := (static-dim-list `x`)?
static-dim-list ::= static-dim (`x` static-dim)*
static-dim ::= (decimal-literal | `[` decimal-literal `]`)
</code></pre><p>The vector type represents a SIMD style vector used by target-specific
operation sets like AVX or SVE. While the most common use is for 1D
vectors (e.g. vector&lt;16 x f32>) we also support multidimensional registers
on targets that support them (like TPUs). The dimensions of a vector type
can be fixed-length, scalable, or a combination of the two. The scalable
dimensions in a vector are indicated between square brackets ([ ]).</p><p>Vector shapes must be positive decimal integers. 0D vectors are allowed by
omitting the dimension: <code>vector&lt;f32></code>.</p><p>Note: hexadecimal integer literals are not allowed in vector type
declarations, <code>vector&lt;0x42xi32></code> is invalid because it is interpreted as a
2D vector with shape <code>(0, 42)</code> and zero shapes are not allowed.</p><h4 id=examples-2>Examples:&nbsp;<a class=headline-hash href=#examples-2>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// A 2D fixed-length vector of 3x42 i32 elements.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x42x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// A 1D scalable-length vector that contains a multiple of 4 f32 elements.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// A 2D scalable-length vector that contains a multiple of 2x8 f32 elements.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=kt>vector</span><span class=p>&lt;[</span><span class=m>2</span><span class=p>]x[</span><span class=m>8</span><span class=p>]</span>xf32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// A 2D mixed fixed/scalable vector that contains 4 scalable vectors of 4 f32 elements.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=p>[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// A 3D mixed fixed/scalable vector in which only the inner dimension is
</span></span></span><span class=line><span class=cl><span class=c>// scalable.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=p>[</span><span class=m>4</span><span class=p>]</span>x8xf32<span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-9>Parameters:&nbsp;<a class=headline-hash href=#parameters-9>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>shape</td><td style=text-align:center><code>::llvm::ArrayRef&lt;int64_t></code></td><td></td></tr><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>::mlir::Type</code></td><td>integer or index or floating-point</td></tr><tr><td style=text-align:center>scalableDims</td><td style=text-align:center><code>::llvm::ArrayRef&lt;bool></code></td><td></td></tr></tbody></table><h3 id=arraytype>ArrayType&nbsp;<a class=headline-hash href=#arraytype>¶</a></h3><p>ReuseIR Array Type</p><p>Syntax:</p><pre tabindex=0><code>!reuse_ir.array&lt;
  mlir::Type,   # elementType
  ::llvm::ArrayRef&lt;size_t&gt;   # sizes
&gt;
</code></pre><p><code>reuse_ir.array</code> is a multi-dimensional array with fixed lengths</p><h4 id=parameters-10>Parameters:&nbsp;<a class=headline-hash href=#parameters-10>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>sizes</td><td style=text-align:center><code>::llvm::ArrayRef&lt;size_t></code></td><td></td></tr></tbody></table><h3 id=closuretype>ClosureType&nbsp;<a class=headline-hash href=#closuretype>¶</a></h3><p>ReuseIR Closure Type</p><p>Syntax:</p><pre tabindex=0><code>!reuse_ir.closure&lt;
  ::llvm::ArrayRef&lt;::mlir::Type&gt;,   # inputTypes
  ::mlir::Type   # outputType
&gt;
</code></pre><p><code>reuse_ir.closure</code> is for capturing lambda expressions.
struct Closure {
void* vtable;
void* arg_start;
void* arg_cursor;
};
struct VTable {
void* func;
void* clone;
void* drop;
}</p><h4 id=parameters-11>Parameters:&nbsp;<a class=headline-hash href=#parameters-11>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>inputTypes</td><td style=text-align:center><code>::llvm::ArrayRef&lt;::mlir::Type></code></td><td></td></tr><tr><td style=text-align:center>outputType</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr></tbody></table><h3 id=mreftype>MRefType&nbsp;<a class=headline-hash href=#mreftype>¶</a></h3><p>ReuseIR Mutable Reference Type</p><p>Syntax:</p><pre tabindex=0><code>!reuse_ir.mref&lt;
  mlir::Type,   # pointee
  ::mlir::reuse_ir::AtomicKindAttr   # atomicKind
&gt;
</code></pre><p><code>reuse_ir.mref</code> is the mutable reference that is assignable inside a unfrozen but freezable object.</p><h4 id=parameters-12>Parameters:&nbsp;<a class=headline-hash href=#parameters-12>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>pointee</td><td style=text-align:center><code>mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>atomicKind</td><td style=text-align:center><code>::mlir::reuse_ir::AtomicKindAttr</code></td><td></td></tr></tbody></table><h3 id=nullabletype>NullableType&nbsp;<a class=headline-hash href=#nullabletype>¶</a></h3><p>ReuseIR Nullable Type</p><p>Syntax:</p><pre tabindex=0><code>!reuse_ir.nullable&lt;
  ::mlir::Type   # pointer
&gt;
</code></pre><p><code>reuse_ir.nullable</code> is a nullable type. Rc pointers and tokens on default at nonnull in ReuseIR.
This is just a type wrapper to indicate that the pointer can be null.</p><h4 id=parameters-13>Parameters:&nbsp;<a class=headline-hash href=#parameters-13>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>pointer</td><td style=text-align:center><code>::mlir::Type</code></td><td></td></tr></tbody></table><h3 id=opaquetype-1>OpaqueType&nbsp;<a class=headline-hash href=#opaquetype-1>¶</a></h3><p>ReuseIR Opaque Type</p><p>Syntax:</p><pre tabindex=0><code>!reuse_ir.opaque&lt;
  mlir::IntegerAttr,   # size
  mlir::IntegerAttr   # alignment
&gt;
</code></pre><p><code>reuse_ir.opaque</code> is an opaque type for externally managed object.
Opaque {
void* drop;
void* clone;
T data;
}</p><h4 id=parameters-14>Parameters:&nbsp;<a class=headline-hash href=#parameters-14>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>size</td><td style=text-align:center><code>mlir::IntegerAttr</code></td><td></td></tr><tr><td style=text-align:center>alignment</td><td style=text-align:center><code>mlir::IntegerAttr</code></td><td></td></tr></tbody></table><h3 id=ptrtype>PtrType&nbsp;<a class=headline-hash href=#ptrtype>¶</a></h3><p>ReuseIR opaque pointer type</p><p>Syntax: <code>!reuse_ir.ptr</code></p><p><code>reuse_ir.ptr</code> is an opaque pointer type.</p><h3 id=rcboxtype>RcBoxType&nbsp;<a class=headline-hash href=#rcboxtype>¶</a></h3><p>ReuseIR Control Box</p><p>Syntax:</p><pre tabindex=0><code>!reuse_ir.rcbox&lt;
  mlir::Type,   # dataType
  ::mlir::reuse_ir::AtomicKindAttr,   # atomicKind
  ::mlir::reuse_ir::FreezingKindAttr   # freezingKind
&gt;
</code></pre><p><code>reuse_ir.rcbox</code> is the underlying control box of RC managed objects.
It has the following varaints:</p><ul><li>Non-atomic plain RC</li><li>Non-atomic freezable RC</li><li>Atomic plain RC</li><li>Atomic freezable RC
For Non-freezable variants, status is simply an index type:</li></ul><pre tabindex=0><code>RcBox&lt;T&gt; {
    size_t status;
    T data;
};
</code></pre><p>For freezable varaints, status is also of the same size but it is actually
a tagged pointer. Please refer to
<a href=https://dl.acm.org/doi/abs/10.1145/3652024.3665507>https://dl.acm.org/doi/abs/10.1145/3652024.3665507</a>
for more details:</p><pre tabindex=0><code>RcBox&lt;T&gt; {
    union {
      size_t status;
      RcBox* root;
    } status;
    RcBox* next;
    void* vtable;
    T data;
};
struct VTable {
  void*  drop;
  size_t size;
  size_t alignment;
  ssize_t scan_count;
  size_t scan_offset[0];
}
- if scan_count &gt;= 0, then scan_offset stores offsets for inner mutable fields (composite types).;
- if scan_count &lt; 0, then scan_offset contains a single value annotates the stride between inner mutable fields (array types).
</code></pre><h4 id=parameters-15>Parameters:&nbsp;<a class=headline-hash href=#parameters-15>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>dataType</td><td style=text-align:center><code>mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>atomicKind</td><td style=text-align:center><code>::mlir::reuse_ir::AtomicKindAttr</code></td><td></td></tr><tr><td style=text-align:center>freezingKind</td><td style=text-align:center><code>::mlir::reuse_ir::FreezingKindAttr</code></td><td></td></tr></tbody></table><h3 id=rctype>RcType&nbsp;<a class=headline-hash href=#rctype>¶</a></h3><p>ReuseIR Rc Pointer Type</p><p>Syntax:</p><pre tabindex=0><code>!reuse_ir.rc&lt;
  mlir::Type,   # pointee
  ::mlir::reuse_ir::AtomicKindAttr,   # atomicKind
  ::mlir::reuse_ir::FreezingKindAttr   # freezingKind
&gt;
</code></pre><p><code>reuse_ir.rc</code> is the Rc pointer to managed object (in box)</p><h4 id=parameters-16>Parameters:&nbsp;<a class=headline-hash href=#parameters-16>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>pointee</td><td style=text-align:center><code>mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>atomicKind</td><td style=text-align:center><code>::mlir::reuse_ir::AtomicKindAttr</code></td><td></td></tr><tr><td style=text-align:center>freezingKind</td><td style=text-align:center><code>::mlir::reuse_ir::FreezingKindAttr</code></td><td></td></tr></tbody></table><h3 id=reftype>RefType&nbsp;<a class=headline-hash href=#reftype>¶</a></h3><p>ReuseIR Reference Type</p><p>Syntax:</p><pre tabindex=0><code>!reuse_ir.ref&lt;
  mlir::Type,   # pointee
  ::mlir::reuse_ir::FreezingKindAttr   # freezingKind
&gt;
</code></pre><p><code>reuse_ir.ref</code> is the referece to the underlying type. It serves as the pointer
in ReuseIR.</p><h4 id=parameters-17>Parameters:&nbsp;<a class=headline-hash href=#parameters-17>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>pointee</td><td style=text-align:center><code>mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>freezingKind</td><td style=text-align:center><code>::mlir::reuse_ir::FreezingKindAttr</code></td><td></td></tr></tbody></table><h3 id=regionctxtype>RegionCtxType&nbsp;<a class=headline-hash href=#regionctxtype>¶</a></h3><p>ReuseIR Region Context</p><p>Syntax: <code>!reuse_ir.region_ctx</code></p><p><code>reuse_ir.region_ctx</code> is used to track mutable subregions.
It contains the root for regional garbage collection.
Region {
FreezableRcHeader* tail;
}
RegionCtx is a pointer to Region. For now, it can be understood as a pointer to a pointer.</p><h3 id=tokentype>TokenType&nbsp;<a class=headline-hash href=#tokentype>¶</a></h3><p>ReuseIR Memory Token</p><p>Syntax:</p><pre tabindex=0><code>!reuse_ir.token&lt;
  size_t,   # alignment
  size_t   # size
&gt;
</code></pre><p><code>reuse_ir.token</code> is the token of the memory</p><h4 id=parameters-18>Parameters:&nbsp;<a class=headline-hash href=#parameters-18>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>alignment</td><td style=text-align:center><code>size_t</code></td><td></td></tr><tr><td style=text-align:center>size</td><td style=text-align:center><code>size_t</code></td><td></td></tr></tbody></table><h3 id=vectortype-1>VectorType&nbsp;<a class=headline-hash href=#vectortype-1>¶</a></h3><p>ReuseIR Vector Type</p><p>Syntax:</p><pre tabindex=0><code>!reuse_ir.vector&lt;
  mlir::Type   # elementType
&gt;
</code></pre><p><code>reuse_ir.vector</code> is a single-dimension vector with dynamic length.
Vec<t> {
T* data;
size_t capacity;
size_t length;
}</p><h4 id=parameters-19>Parameters:&nbsp;<a class=headline-hash href=#parameters-19>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>mlir::Type</code></td><td></td></tr></tbody></table><div class=edit-meta><br><a href=https://github.com/SchrodingerZhu/ReuseIR/tree/main/reuse-www/edit/main/website/content/dialect/code_docs/ReuseIRTypes.md class=edit-page><i class="fas fa-pen-square"></i> Edit on GitHub</a></div><nav class=pagination><a class="nav nav-prev" href=https://SchrodingerZhu.github.io/ReuseIR/dialect/code_docs/ReuseIRPasses/ title=Passes><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - Passes</a>
<a class="nav nav-next" href=https://SchrodingerZhu.github.io/ReuseIR/dialect/code_docs/ReuseIRCompositeLayoutInterface/ title=CompositeLayoutInterface>Next - CompositeLayoutInterface <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://SchrodingerZhu.github.io/ReuseIR>Home</a></li><li><a href=https://SchrodingerZhu.github.io/ReuseIR/runtime/>Runtime</a></li><li><a href=https://SchrodingerZhu.github.io/ReuseIR/frontend/>Frontend</a></li><li class="parent has-sub-menu"><a href=https://SchrodingerZhu.github.io/ReuseIR/dialect/>Dialect<span class="mark opened">-</span></a><ul class=sub-menu><li class="parent has-sub-menu"><a href=https://SchrodingerZhu.github.io/ReuseIR/dialect/code_docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://SchrodingerZhu.github.io/ReuseIR/dialect/code_docs/ReuseIRCompositeLayoutInterface/>CompositeLayoutInterface</a></li><li><a href=https://SchrodingerZhu.github.io/ReuseIR/dialect/code_docs/ReuseIRDialect/>Dialect</a></li><li><a href=https://SchrodingerZhu.github.io/ReuseIR/dialect/code_docs/ReuseIRMangleInterface/>MangleInterface</a></li><li><a href=https://SchrodingerZhu.github.io/ReuseIR/dialect/code_docs/ReuseIROps/>Ops</a></li><li><a href=https://SchrodingerZhu.github.io/ReuseIR/dialect/code_docs/ReuseIRPasses/>Passes</a></li><li class=active><a href=https://SchrodingerZhu.github.io/ReuseIR/dialect/code_docs/ReuseIRTypes/>Types</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>